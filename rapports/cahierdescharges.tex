\chapter{Cahier des charges}
\section{Premier prototype}
Il s'agit premièrement d'implémenter la fonction basique de notre programme: la résolution du cube. Nous allons donc lui fournir en entrée un fichier contenant les couleurs de toutes les facettes du cube. Le programme cherchera à le résoudre et renverra les mouvements nécessaires à sa résolution. Par exemple en utilisant la notation de Singmaster\cite{cite11}.
Différentes méthodes sont pour l'instant envisagées:
\begin{itemize}
    \item La première consiste à implémenter un algorithme de résolution simple: par exemple le premier algorithme généralement appris par les humains.\cite{cite2} Le principe de celui-ci est d'envisager la résolution dans l'ordre suivant: d'abord une face, puis la première couronne, la seconde couronne et enfin la dernière face\cite{cite2}. Pour résoudre le Rubik's Cube de cette manière, le programme devra être capable de reconnaître la configuration dans laquelle se trouve le cube à un moment donné et lui
    appliquer une procédure, c'est-à-dire une suite prédéfinie de rotations. Les autres méthodes utilisées par les humains reposent sur ce même principe avec différentes configurations et procédures. Dans le cas des méthodes dites avancées, c'est-à-dire permettant de résoudre le Rubik's Cube en un plus petit nombre de rotations, le nombre de configurations et de procédures à apprendre augmente drastiquement.
\item Un algorithme reposant sur une machine de Boltzmann\cite{cite10} est également envisagée. Cet algorithme aurait une fonction d'évaluation de l'énergie du cube (plus le cube est proche de sa résolution, plus son énergie est faible) et chercherait à minimiser cette énergie via des rotations aléatoires ou des procédures aléatoires. Ces procédures auraient d'autant plus de chances d'être choisie que leur action réduit l'énergie du cube. Cet algorithme pourrait être utilisé conjointement avec le premier pour la résolution.
\item Un troisième algorithme dit en deux phases consiste à utiliser un algorithme A*\cite{cite3} (parcours d'un arbre en profondeur amélioré par une heuristique) pour placer les angles du cube au bon endroit lors de la première phase. La seconde phase consiste à utiliser réduire le nombre des rotations possibles à un groupe de cardinal plus petit.\footnote{Plus d'information sur les groupes du cube \cite{cite12}} Cet algorithme permet de résoudre le Rubik's Cube en une vingtaine de coups, mais est également plus dur à implémenter\cite{cite0}. Cet
    algorithme est une amélioration d'un algorithme passant par 5 groupes\cite{cite4}.
\end{itemize}

\section{L'affichage en 3D}
La prochaine étape du développement consiste à faire une interface homme machine. Il faut que l'utilisateur puisse visualiser les étapes successives de résolution du Rubik's Cube. Pour cela nous comptons afficher une fenêtre avec un bouton pour aller à l'étape suivante et une image en 3D de la configuration du cube que l'utilisateur devrait avoir dans les mains.

\section{\textit{Computer vision}}
Une fois que l'affichage a été réalisé, il faut pouvoir permettre de rentrer la configuration du cube au départ. Pour cela nous présenterons les différentes faces du cube à la caméra et un algorithme de traitement d'image\footnote{L'algorithme pourra être réalisé grâce à la bibliothèque OpenCV\cite{cite7}} sera capable de reconstituer le cube virtuellement.


